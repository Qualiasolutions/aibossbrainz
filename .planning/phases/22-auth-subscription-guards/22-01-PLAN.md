---
phase: 22-auth-subscription-guards
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/(chat)/api/voice/route.ts
  - app/(chat)/api/realtime/route.ts
  - app/(chat)/api/realtime/stream/route.ts
  - app/(chat)/api/export-user-data/route.ts
  - app/api/demo/chat/route.ts
  - components/landing/interactive-chat-demo.tsx
  - lib/supabase/middleware.ts
autonomous: true

must_haves:
  truths:
    - "Voice TTS endpoint rejects requests from users with expired subscriptions (returns subscription_expired error)"
    - "Realtime voice chat endpoints reject requests from users with expired subscriptions (returns subscription_expired error)"
    - "Voice rate limiting DB fallback queries UserAnalytics for voice entries, not Message_v2"
    - "Realtime stream rate limiting DB fallback queries UserAnalytics for voice entries, not Message_v2"
    - "Export rate limiting works when Redis is unavailable (queries AuditLog for DATA_EXPORT actions)"
    - "Demo chat endpoint validates CSRF tokens on POST requests"
    - "Demo chat still works for unauthenticated visitors (CSRF token obtainable without auth)"
  artifacts:
    - path: "app/(chat)/api/voice/route.ts"
      provides: "Subscription check + correct voice rate limit DB fallback"
      contains: "checkUserSubscription"
    - path: "app/(chat)/api/realtime/route.ts"
      provides: "Subscription check before AI generation and TTS"
      contains: "checkUserSubscription"
    - path: "app/(chat)/api/realtime/stream/route.ts"
      provides: "Subscription check + correct voice rate limit DB fallback"
      contains: "checkUserSubscription"
    - path: "app/(chat)/api/export-user-data/route.ts"
      provides: "AuditLog-based DB fallback for rate limiting"
      contains: "AuditLog"
    - path: "app/api/demo/chat/route.ts"
      provides: "CSRF-protected demo chat"
      contains: "withCsrf"
    - path: "components/landing/interactive-chat-demo.tsx"
      provides: "CSRF token fetch and header injection for demo chat"
      contains: "useCsrf"
    - path: "lib/supabase/middleware.ts"
      provides: "Public access to /api/csrf for unauthenticated CSRF token retrieval"
      contains: "/api/csrf"
  key_links:
    - from: "app/(chat)/api/voice/route.ts"
      to: "lib/db/queries/user.ts"
      via: "checkUserSubscription import"
      pattern: "checkUserSubscription"
    - from: "app/(chat)/api/voice/route.ts"
      to: "UserAnalytics table"
      via: "createServiceClient query"
      pattern: "UserAnalytics.*metricType.*voice"
    - from: "app/(chat)/api/export-user-data/route.ts"
      to: "AuditLog table"
      via: "createServiceClient query"
      pattern: "AuditLog.*DATA_EXPORT"
    - from: "components/landing/interactive-chat-demo.tsx"
      to: "app/api/demo/chat/route.ts"
      via: "csrfFetch with X-CSRF-Token header"
      pattern: "csrfFetch.*api/demo/chat"
    - from: "app/api/demo/chat/route.ts"
      to: "lib/security/with-csrf.ts"
      via: "withCsrf wrapper"
      pattern: "withCsrf"
---

<objective>
Close subscription enforcement gaps on voice/realtime endpoints, fix rate limit DB fallbacks, and add CSRF protection to the demo chat route.

Purpose: Prevent expired users from consuming paid ElevenLabs TTS and AI resources. Ensure rate limiting actually works when Redis is unavailable. Protect demo endpoint from cross-origin abuse.
Output: All five AUTH requirements (AUTH-01 through AUTH-05) implemented using existing codebase patterns.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-auth-subscription-guards/22-RESEARCH.md
@app/(chat)/api/chat/route.ts (reference implementation for subscription check + rate limit pattern)
@lib/db/queries/user.ts (checkUserSubscription function)
@lib/security/rate-limiter.ts (checkRateLimit function)
@lib/security/with-csrf.ts (withCsrf HOF)
@lib/security/csrf.ts (CSRF token generation/validation)
@hooks/use-csrf.ts (client-side CSRF hook)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add subscription checks and fix rate limit DB fallbacks (AUTH-01, AUTH-02, AUTH-03, AUTH-05)</name>
  <files>
    app/(chat)/api/voice/route.ts
    app/(chat)/api/realtime/route.ts
    app/(chat)/api/realtime/stream/route.ts
    app/(chat)/api/export-user-data/route.ts
  </files>
  <action>
Apply the existing `checkUserSubscription()` pattern from the chat route to voice and realtime endpoints, and fix the DB fallback rate limiting in voice, realtime/stream, and export routes.

**AUTH-01: Voice subscription check** (`app/(chat)/api/voice/route.ts`)
- Add `import { checkUserSubscription } from "@/lib/db/queries";` (may already be partially imported -- check existing imports)
- Insert after the auth check (after `if (!user)` block, ~line 48) and BEFORE rate limiting:
  ```
  const subscriptionStatus = await checkUserSubscription(user.id);
  if (!subscriptionStatus.isActive) {
    return new ChatSDKError("subscription_expired:chat").toResponse();
  }
  ```

**AUTH-03: Fix voice rate limit DB fallback** (`app/(chat)/api/voice/route.ts`)
- Add `import { createServiceClient } from "@/lib/supabase/server";` if not already imported
- Replace the `else` block at lines 71-82 (the `getMessageCountByUserId` fallback) with a query to UserAnalytics:
  ```
  } else {
    // SECURITY: Redis unavailable - verify via UserAnalytics (fail closed)
    // Voice requests are tracked via recordAnalytics(userId, "voice", ...)
    // recordAnalytics uses an RPC upsert that increments voiceMinutes on the daily row.
    // Since it aggregates into one row per day, count the voiceMinutes value directly.
    const supabaseService = createServiceClient();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const { data, error } = await supabaseService
      .from("UserAnalytics")
      .select("voiceMinutes")
      .eq("userId", user.id)
      .gte("date", today.toISOString())
      .maybeSingle();

    if (error) {
      // Fail closed - deny on error
      return new ChatSDKError("rate_limit:chat").toResponse();
    }

    // voiceMinutes tracks estimated minutes; use as a proxy for request count
    // Each voice request records at least 1 minute, so voiceMinutes >= request count
    if ((data?.voiceMinutes ?? 0) >= MAX_VOICE_REQUESTS_PER_DAY) {
      return new ChatSDKError("rate_limit:chat").toResponse();
    }
  }
  ```
- Remove the now-unused `getMessageCountByUserId` import IF it is not used elsewhere in this file (it should only be in the old fallback)

**AUTH-02: Realtime subscription check** (`app/(chat)/api/realtime/route.ts`)
- Add `import { checkUserSubscription } from "@/lib/db/queries";`
- Insert after the auth check (after `if (!user)` block, ~line 42), before `apiLog.start`:
  ```
  const subscriptionStatus = await checkUserSubscription(user.id);
  if (!subscriptionStatus.isActive) {
    return new ChatSDKError("subscription_expired:chat").toResponse();
  }
  ```

**AUTH-02 + AUTH-03: Realtime stream subscription check + DB fallback fix** (`app/(chat)/api/realtime/stream/route.ts`)
- Add `import { checkUserSubscription } from "@/lib/db/queries";`
- Add `import { createServiceClient } from "@/lib/supabase/server";` if not already imported
- Insert subscription check after auth check (after `if (!user)` block, ~line 119), before rate limiting:
  ```
  const subscriptionStatus = await checkUserSubscription(user.id);
  if (!subscriptionStatus.isActive) {
    return new ChatSDKError("subscription_expired:chat").toResponse();
  }
  ```
- Replace the `else` DB fallback block (the `getMessageCountByUserId` fallback) with the same UserAnalytics query pattern used in the voice route above (query `voiceMinutes` for today, fail closed on error)
- Remove unused `getMessageCountByUserId` import if it is no longer referenced

**AUTH-05: Fix export rate limit DB fallback** (`app/(chat)/api/export-user-data/route.ts`)
- Add `import { createServiceClient } from "@/lib/supabase/server";` (service client needed for AuditLog query across RLS)
- Replace the rate limit check at lines 55-67 with a two-branch pattern that handles both Redis and DB fallback:
  ```
  const rateLimit = await checkRateLimit(user.id, EXPORT_RATE_LIMIT, "export");

  if (rateLimit.source === "redis") {
    if (!rateLimit.allowed) {
      return Response.json(
        { error: "Too many export requests. Please try again tomorrow." },
        {
          status: 429,
          headers: getRateLimitHeaders(
            rateLimit.remaining,
            EXPORT_RATE_LIMIT,
            rateLimit.reset,
          ),
        },
      );
    }
  } else {
    // SECURITY: Redis unavailable - verify via AuditLog (fail closed)
    const supabaseService = createServiceClient();
    const cutoffTime = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
    const { count, error } = await supabaseService
      .from("AuditLog")
      .select("*", { count: "exact", head: true })
      .eq("userId", user.id)
      .eq("action", "DATA_EXPORT")
      .gte("createdAt", cutoffTime);

    if (error) {
      // Fail closed
      return Response.json(
        { error: "Unable to verify export limit. Please try again." },
        { status: 503 },
      );
    }

    if ((count ?? 0) >= EXPORT_RATE_LIMIT) {
      return Response.json(
        { error: "Too many export requests. Please try again tomorrow." },
        { status: 429 },
      );
    }
  }
  ```
- The key fix: the old code used `!rateLimit.allowed && !rateLimit.requiresDatabaseCheck` which silently passes when `requiresDatabaseCheck` is true. The new code checks `rateLimit.source === "redis"` instead.
  </action>
  <verify>
1. `grep -n "checkUserSubscription" app/\(chat\)/api/voice/route.ts app/\(chat\)/api/realtime/route.ts app/\(chat\)/api/realtime/stream/route.ts` -- all three files must show the import and usage
2. `grep -n "UserAnalytics" app/\(chat\)/api/voice/route.ts app/\(chat\)/api/realtime/stream/route.ts` -- both must query UserAnalytics (not Message_v2)
3. `grep -n "getMessageCountByUserId" app/\(chat\)/api/voice/route.ts app/\(chat\)/api/realtime/stream/route.ts` -- should NOT appear (removed)
4. `grep -n "AuditLog" app/\(chat\)/api/export-user-data/route.ts` -- must show AuditLog query
5. `grep -n "requiresDatabaseCheck" app/\(chat\)/api/export-user-data/route.ts` -- should NOT appear (replaced with source check)
6. `pnpm build` passes without type errors
  </verify>
  <done>
- Voice route checks subscription before any ElevenLabs call and queries UserAnalytics (not Message_v2) for DB fallback rate limiting
- Both realtime routes check subscription before AI generation and TTS
- Realtime stream route queries UserAnalytics (not Message_v2) for DB fallback rate limiting
- Export route uses AuditLog-based DB fallback that correctly denies when Redis is down
- All changes follow the exact patterns from the chat route reference implementation
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CSRF protection to demo chat endpoint (AUTH-04)</name>
  <files>
    app/api/demo/chat/route.ts
    components/landing/interactive-chat-demo.tsx
    lib/supabase/middleware.ts
  </files>
  <action>
Add CSRF protection to the demo chat endpoint. This requires three coordinated changes: wrapping the route handler, updating the client to send CSRF tokens, and making the CSRF endpoint accessible to unauthenticated users.

**Step 1: Make /api/csrf publicly accessible** (`lib/supabase/middleware.ts`)
- Add `"/api/csrf"` to the `publicApiRoutes` array (after the `/api/demo/chat` entry)
- This is required because the CSRF endpoint is at `app/(chat)/api/csrf/route.ts` which maps to `/api/csrf`, but it's currently blocked by the auth middleware for unauthenticated visitors
- The CSRF endpoint only generates/validates tokens (no data exposure), so public access is safe

**Step 2: Wrap demo route with CSRF** (`app/api/demo/chat/route.ts`)
- Add `import { withCsrf } from "@/lib/security/with-csrf";`
- Change `export async function POST(request: Request) {` to `export const POST = withCsrf(async (request: Request) => {`
- Change the closing `}` of the POST function to `});`
- Everything inside the handler body stays exactly the same

**Step 3: Add CSRF to demo chat client** (`components/landing/interactive-chat-demo.tsx`)
- Add `import { useCsrf } from "@/hooks/use-csrf";` at the top with other imports
- Inside `InteractiveChatDemo` component, add the hook: `const { csrfFetch } = useCsrf();`
- In the `sendMessage` callback, replace the `fetch("/api/demo/chat", {` call (~line 83) with `csrfFetch("/api/demo/chat", {` -- this automatically adds the X-CSRF-Token header and includes credentials
- The `csrfFetch` function from `useCsrf()` hook handles everything: fetches a CSRF token on mount via `GET /api/csrf`, caches it, and injects the `X-CSRF-Token` header on every request
- Add `csrfFetch` to the `sendMessage` useCallback dependency array
  </action>
  <verify>
1. `grep -n "withCsrf" app/api/demo/chat/route.ts` -- must show import and usage
2. `grep -n "useCsrf\|csrfFetch" components/landing/interactive-chat-demo.tsx` -- must show hook import and csrfFetch usage
3. `grep -n "/api/csrf" lib/supabase/middleware.ts` -- must show it in publicApiRoutes
4. `grep -n "export const POST = withCsrf" app/api/demo/chat/route.ts` -- must match
5. `pnpm build` passes without type errors
  </verify>
  <done>
- Demo chat route is wrapped with `withCsrf()` preventing cross-origin POST abuse
- Demo chat client fetches CSRF token on mount and sends it with every request
- `/api/csrf` is publicly accessible so unauthenticated demo visitors can obtain tokens
- Demo chat still works for first-time anonymous visitors (no auth required, just CSRF)
  </done>
</task>

</tasks>

<verification>
1. All five AUTH requirements addressed:
   - AUTH-01: `checkUserSubscription` in voice route
   - AUTH-02: `checkUserSubscription` in both realtime routes
   - AUTH-03: UserAnalytics-based DB fallback in voice and realtime/stream routes
   - AUTH-04: `withCsrf` on demo route + client CSRF headers + public CSRF endpoint
   - AUTH-05: AuditLog-based DB fallback in export route
2. `pnpm build` succeeds with no type errors
3. No regressions: existing authenticated voice/realtime/export flows still work (subscription check is additive)
4. Security: All fail-closed patterns (deny on DB query error, deny on missing CSRF token)
</verification>

<success_criteria>
- `checkUserSubscription` appears in voice, realtime, and realtime/stream routes
- `getMessageCountByUserId` is removed from voice and realtime/stream routes (replaced by UserAnalytics query)
- Export route rate limit uses `rateLimit.source === "redis"` branching (not the buggy `!allowed && !requiresDatabaseCheck`)
- Demo route uses `withCsrf` wrapper and client sends CSRF headers via `csrfFetch`
- `/api/csrf` is in the middleware public routes list
- `pnpm build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/22-auth-subscription-guards/22-01-SUMMARY.md`
</output>
