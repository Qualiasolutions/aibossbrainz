---
phase: 15-billing-knowledge-base-platform
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/ai/knowledge-base.ts
  - app/api/admin/knowledge-base/fireflies/route.ts
  - app/(admin)/admin/settings/page.tsx
autonomous: true
user_setup:
  - service: fireflies
    why: "Fireflies API access for transcript fetching"
    env_vars:
      - name: FIREFLIES_API_KEY
        source: "Fireflies.ai > Settings > Developer Settings > API Key"

must_haves:
  truths:
    - "Admin can submit a Fireflies transcript ID and have its content stored in the database"
    - "Knowledge base system loads transcripts from Supabase in addition to filesystem"
    - "Ingested transcripts are included in executive chat context"
  artifacts:
    - path: "app/api/admin/knowledge-base/fireflies/route.ts"
      provides: "POST endpoint that fetches Fireflies transcript, transforms to markdown, stores in Supabase"
      exports: ["POST"]
    - path: "lib/ai/knowledge-base.ts"
      provides: "Extended getKnowledgeBaseContent that also queries Supabase knowledge_base_content table"
      contains: "knowledge_base_content"
  key_links:
    - from: "app/api/admin/knowledge-base/fireflies/route.ts"
      to: "Fireflies GraphQL API"
      via: "fetch to https://api.fireflies.ai/graphql"
      pattern: "fireflies\\.ai/graphql"
    - from: "app/api/admin/knowledge-base/fireflies/route.ts"
      to: "Supabase knowledge_base_content table"
      via: "insert into knowledge_base_content"
      pattern: "knowledge_base_content"
    - from: "lib/ai/knowledge-base.ts"
      to: "Supabase knowledge_base_content table"
      via: "select from knowledge_base_content filtered by botType"
      pattern: "knowledge_base_content"
---

<objective>
Enable Fireflies call transcript ingestion into the executive knowledge base via an admin API endpoint and extend the knowledge base system to load from Supabase.

Purpose: Alexandria's team records sales calls on Fireflies. Those transcripts need to feed into the AI executives' knowledge base so they can reference real call context. Since Vercel has a read-only filesystem, transcripts must be stored in Supabase.
Output: Supabase table for KB content, Fireflies ingestion endpoint, KB loader that merges filesystem + DB content.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-billing-knowledge-base-platform/15-RESEARCH.md
@lib/ai/knowledge-base.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create knowledge_base_content table and Fireflies ingestion endpoint</name>
  <files>app/api/admin/knowledge-base/fireflies/route.ts</files>
  <action>
  1. **Create Supabase migration** for the `knowledge_base_content` table using the Supabase MCP tool `apply_migration`:
     - Table: `knowledge_base_content`
     - Columns:
       - `id` text PRIMARY KEY DEFAULT gen_random_uuid()::text
       - `title` text NOT NULL
       - `source` text NOT NULL (e.g., 'fireflies', 'manual')
       - `source_id` text (Fireflies transcript ID, nullable for manual entries)
       - `bot_type` text NOT NULL (one of 'alexandria', 'kim', 'shared')
       - `content` text NOT NULL (the transformed markdown content)
       - `metadata` jsonb DEFAULT '{}'::jsonb (store duration, speakers, date, etc.)
       - `created_at` timestamptz DEFAULT now()
       - `updated_at` timestamptz DEFAULT now()
     - Add RLS: Enable RLS, create policy allowing service_role full access.
     - Add unique constraint on (`source`, `source_id`) WHERE `source_id IS NOT NULL` to prevent re-ingesting same transcript.
     - **Project ID:** `esymbjpzjjkffpfqukxw`

  2. **Create `app/api/admin/knowledge-base/fireflies/route.ts`**:
     - POST handler that:
       a. Authenticates via Supabase, checks user is admin (`isAdmin` field on User table).
       b. Accepts JSON body: `{ transcriptId: string, botType: 'alexandria' | 'kim' | 'shared' }`.
       c. Validates `FIREFLIES_API_KEY` env var exists.
       d. Fetches transcript from Fireflies GraphQL API:
          ```
          POST https://api.fireflies.ai/graphql
          Headers: { Authorization: Bearer ${FIREFLIES_API_KEY}, Content-Type: application/json }
          Body: { query: "query($id: String!) { transcript(id: $id) { title date duration sentences { text speaker_name } summary { overview action_items topics_discussed } speakers { name } } }", variables: { id: transcriptId } }
          ```
       e. Transforms response into structured markdown:
          ```
          # Meeting: {title}
          **Date:** {date} | **Duration:** {duration}min
          **Attendees:** {speakers.map(s => s.name).join(', ')}

          ## Summary
          {summary.overview}

          ## Key Topics
          {summary.topics_discussed}

          ## Action Items
          {summary.action_items}

          ## Full Transcript
          **{speaker_name}:** {text}
          ...
          ```
       f. Inserts into `knowledge_base_content` table using service client (createServiceClient from lib/supabase/server).
       g. Calls `clearKnowledgeBaseCache()` from `lib/ai/knowledge-base.ts` to bust cache.
       h. Returns `{ success: true, title, id }`.
     - Handle duplicate ingestion: if unique constraint violated, return 409 with message "Transcript already ingested".
     - Handle Fireflies API errors gracefully with appropriate error messages.
  </action>
  <verify>
  - `pnpm lint` passes on the new file.
  - `grep -rn "fireflies.ai/graphql" app/api/admin/knowledge-base/fireflies/route.ts` confirms API call.
  - `grep -rn "knowledge_base_content" app/api/admin/knowledge-base/fireflies/route.ts` confirms table usage.
  - Migration applied successfully (check via `list_migrations` MCP tool).
  </verify>
  <done>
  - `knowledge_base_content` table exists in Supabase with RLS and unique constraint.
  - POST endpoint fetches transcript from Fireflies, transforms to markdown, stores in DB.
  - Duplicate ingestion returns 409.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend knowledge base loader to include Supabase content</name>
  <files>lib/ai/knowledge-base.ts, app/(admin)/admin/settings/page.tsx</files>
  <action>
  1. **In `lib/ai/knowledge-base.ts`**, update `getKnowledgeBaseContent()`:
     - After loading filesystem content (existing logic), also query Supabase for additional content.
     - Import `createServiceClient` from `@/lib/supabase/server`.
     - Add a new function `getSupabaseKnowledgeContent(botType: string): Promise<string>`:
       - Use `createServiceClient()` to query `knowledge_base_content` table.
       - For `botType === 'alexandria'`: query WHERE `bot_type` IN ('alexandria', 'shared').
       - For `botType === 'kim'`: query WHERE `bot_type` IN ('kim', 'shared').
       - For `botType === 'collaborative'`: query all rows.
       - Select `title, content, source, created_at`.
       - Order by `created_at` DESC.
       - Format each row as: `\n\n--- {title} (from {source}) ---\n{content}`
       - Join all rows and return.
       - Wrap in try/catch -- if Supabase query fails (e.g., table doesn't exist yet), return empty string silently. This ensures backward compatibility.
     - In the main `getKnowledgeBaseContent()` function, after assembling filesystem content, append Supabase content:
       ```typescript
       const dbContent = await getSupabaseKnowledgeContent(botType);
       if (dbContent) {
         content += `\n\n=== Ingested Knowledge ===\n${dbContent}`;
       }
       ```
     - Place this INSIDE the requestCoalescer callback, after the filesystem reads but before caching.

  2. **In `app/(admin)/admin/settings/page.tsx`** (or the admin settings area):
     - Add a simple "Fireflies Transcript Ingestion" section with:
       - Text input for Fireflies Transcript ID.
       - Dropdown for bot_type: "Alexandria", "Kim", "Shared".
       - "Ingest" button that POSTs to `/api/admin/knowledge-base/fireflies`.
       - Show success/error toast feedback.
     - If the admin settings page doesn't exist or is too complex, create a minimal admin page at `app/(admin)/admin/knowledge-base/page.tsx` instead with just this form.
     - Keep it simple -- just a form with the two fields and a submit button.
  </action>
  <verify>
  - `pnpm lint` passes on both files.
  - `grep -n "getSupabaseKnowledgeContent" lib/ai/knowledge-base.ts` confirms the new function.
  - `grep -n "Ingested Knowledge" lib/ai/knowledge-base.ts` confirms DB content is appended.
  - `grep -n "knowledge-base/fireflies" app/(admin)/admin/` confirms admin UI references the endpoint.
  </verify>
  <done>
  - Knowledge base loader queries both filesystem and Supabase for content.
  - If Supabase table doesn't exist or query fails, filesystem-only behavior is preserved.
  - Admin UI provides a simple form to trigger Fireflies transcript ingestion.
  - KB cache is busted after ingestion so new content is immediately available.
  </done>
</task>

</tasks>

<verification>
1. `pnpm lint` passes on all modified/created files.
2. Supabase `knowledge_base_content` table exists with correct schema and RLS.
3. Knowledge base content includes `=== Ingested Knowledge ===` section when DB content exists.
4. Admin can input a Fireflies transcript ID and select a bot type to ingest.
5. Fireflies endpoint validates admin auth, handles API errors, and prevents duplicate ingestion.
</verification>

<success_criteria>
- Fireflies transcripts can be fetched, transformed, and stored in Supabase via admin endpoint.
- Knowledge base system loads content from both filesystem and Supabase.
- Ingested content appears in AI executive chat context for the assigned bot type.
- System gracefully degrades if Supabase table or Fireflies API is unavailable.
</success_criteria>

<output>
After completion, create `.planning/phases/15-billing-knowledge-base-platform/15-02-SUMMARY.md`
</output>
