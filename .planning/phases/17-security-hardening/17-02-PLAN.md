---
phase: 17-security-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/(chat)/api/realtime/route.ts
  - app/(chat)/api/realtime/stream/route.ts
  - app/api/health/route.ts
autonomous: true

must_haves:
  truths:
    - "Realtime endpoint rejects messages longer than 5000 chars with a 400 response"
    - "Realtime endpoint rejects invalid botType values with a 400 response"
    - "Realtime stream endpoint validates chatId as UUID when provided"
    - "Health endpoint returns only {status: 'ok'|'degraded'} for unauthenticated requests -- no service names"
    - "Health endpoint returns full service details for authenticated requests"
    - "Health endpoint preserves HTTP 200/503 status codes for monitoring compatibility"
  artifacts:
    - path: "app/(chat)/api/realtime/route.ts"
      provides: "Zod-validated realtime voice endpoint"
      contains: "realtimeRequestSchema"
    - path: "app/(chat)/api/realtime/stream/route.ts"
      provides: "Zod-validated realtime stream endpoint"
      contains: "realtimeStreamSchema"
    - path: "app/api/health/route.ts"
      provides: "Two-tier health endpoint (auth/unauth)"
      contains: "createClient"
  key_links:
    - from: "app/(chat)/api/realtime/route.ts"
      to: "zod"
      via: "z.object schema for request body"
      pattern: "z\\.object"
    - from: "app/(chat)/api/realtime/stream/route.ts"
      to: "zod"
      via: "z.object schema for request body"
      pattern: "z\\.object"
    - from: "app/api/health/route.ts"
      to: "lib/supabase/server"
      via: "createClient for auth check"
      pattern: "createClient"
---

<objective>
Add Zod input validation to both realtime route handlers and convert the health endpoint to a two-tier response that hides internal service names from unauthenticated callers.

Purpose: Close SEC-03 (realtime input validation) and SEC-04 (health endpoint information disclosure) from the production audit.
Output: Three hardened files -- two realtime routes with Zod schemas, one health endpoint with auth-aware response.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-security-hardening/17-RESEARCH.md
@app/(chat)/api/realtime/route.ts
@app/(chat)/api/realtime/stream/route.ts
@app/api/health/route.ts
@app/(chat)/api/chat/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Zod validation to realtime routes (SEC-03)</name>
  <files>app/(chat)/api/realtime/route.ts, app/(chat)/api/realtime/stream/route.ts</files>
  <action>
  Add Zod request body schemas to both realtime route handlers, replacing the manual `typeof` checks.

  **For `app/(chat)/api/realtime/route.ts`:**

  1. Add `import { z } from "zod";` to imports
  2. Define the schema at module level (after imports, before `export const maxDuration`):
     ```typescript
     const realtimeRequestSchema = z.object({
       message: z.string().min(1, "Message is required").max(5000, "Message too long"),
       botType: z.enum(["alexandria", "kim", "collaborative"]).default("collaborative"),
     });
     ```
  3. Replace lines 33-42 (the manual `request.json()` + validation) with:
     ```typescript
     const parseResult = realtimeRequestSchema.safeParse(await request.json());
     if (!parseResult.success) {
       return new ChatSDKError("bad_request:api").toResponse();
     }
     const { message, botType } = parseResult.data;
     ```
  4. Remove the `validBotTypes` const and the manual `if (!message || typeof message !== "string")` check -- Zod handles both.
  5. Remove the `as const` type assertion on validBotTypes since it no longer exists.
  6. The `botType` cast `as "alexandria" | "kim" | "collaborative"` on line 50 is no longer needed since Zod already types it correctly. Clean up any remaining botType casts in this file.

  **For `app/(chat)/api/realtime/stream/route.ts`:**

  1. Add `import { z } from "zod";` to imports
  2. Define the schema at module level:
     ```typescript
     const realtimeStreamSchema = z.object({
       message: z.string().min(1, "Message is required").max(5000, "Message too long"),
       botType: z.enum(["alexandria", "kim", "collaborative"]).default("collaborative"),
       chatId: z.string().uuid("Invalid chat ID").optional(),
     });
     ```
  3. Replace lines 134-146 (the manual `request.json()` + validation) with:
     ```typescript
     const parseResult = realtimeStreamSchema.safeParse(await request.json());
     if (!parseResult.success) {
       return new ChatSDKError("bad_request:api").toResponse();
     }
     const { message, botType, chatId: existingChatId } = parseResult.data;
     ```
  4. Remove the manual `if (!message || typeof message !== "string")` and `if (!["alexandria", "kim", "collaborative"].includes(botType))` checks.
  5. Clean up `botType as BotType` casts where Zod's enum already provides the correct type. The `BotType` import may still be needed for other usages (like `getKnowledgeBaseContent`) -- check before removing.

  **Wrap request.json() in try/catch:** Both routes should handle malformed JSON (non-JSON body). Wrap the `safeParse(await request.json())` in a try/catch that returns `ChatSDKError("bad_request:api")` on JSON parse failure:
  ```typescript
  let body: unknown;
  try {
    body = await request.json();
  } catch {
    return new ChatSDKError("bad_request:api").toResponse();
  }
  const parseResult = realtimeRequestSchema.safeParse(body);
  ```

  This matches the defensive pattern -- Zod validates shape, try/catch handles malformed JSON.
  </action>
  <verify>
  Run: `grep -n "z.object" app/\(chat\)/api/realtime/route.ts app/\(chat\)/api/realtime/stream/route.ts` -- should show schemas in both files.
  Run: `grep -n "typeof message" app/\(chat\)/api/realtime/route.ts app/\(chat\)/api/realtime/stream/route.ts` -- should return nothing (manual checks removed).
  Run: `grep -n "safeParse\|\.parse" app/\(chat\)/api/realtime/route.ts app/\(chat\)/api/realtime/stream/route.ts` -- should show safeParse usage.
  Run: `grep -n "max(5000)" app/\(chat\)/api/realtime/route.ts app/\(chat\)/api/realtime/stream/route.ts` -- should show the 5000 char limit.
  Run: `pnpm lint` -- should pass.
  </verify>
  <done>
  Both realtime routes validate request bodies with Zod schemas. Messages are limited to 5000 chars. botType is validated as an enum. chatId (stream only) is validated as UUID. Manual typeof checks are removed. Malformed JSON returns 400.
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert health endpoint to two-tier response (SEC-04)</name>
  <files>app/api/health/route.ts</files>
  <action>
  Add auth-aware response to the health endpoint: authenticated users get full service details, unauthenticated users get only a status string.

  Steps:
  1. Add `import { createClient } from "@/lib/supabase/server";` to imports (keep existing `createServiceClient` import)
  2. After computing `services` and `overall` (the existing health check logic stays unchanged), add auth check before the response:
     ```typescript
     const statusCode = overall === "healthy" ? 200 : 503;

     // Authenticated users get full service details for debugging.
     // Unauthenticated callers (monitoring probes) get only a status string.
     try {
       const supabase = await createClient();
       const { data: { user } } = await supabase.auth.getUser();

       if (user) {
         return NextResponse.json(
           { status: overall, timestamp: new Date().toISOString(), services },
           { status: statusCode }
         );
       }
     } catch {
       // Auth check failed -- fall through to minimal response
     }

     // Unauthenticated: minimal response (no service names, no timestamp)
     return NextResponse.json(
       { status: overall === "healthy" ? "ok" : "degraded" },
       { status: statusCode }
     );
     ```
  3. Remove the old return statement (the current `return NextResponse.json(...)` at the bottom)
  4. The health check logic itself (Supabase ping, circuit breaker checks) stays exactly the same -- only the response changes

  Key constraints:
  - HTTP status codes MUST remain 200 (healthy) and 503 (degraded) -- monitoring tools depend on these
  - The `createServiceClient()` for the DB health check stays -- it uses the service role key to test DB connectivity
  - The `createClient()` for auth check uses the user's session cookie -- this is the standard Supabase auth pattern
  - If auth check itself fails (no cookies, expired session), fall through to minimal response -- never crash the health endpoint
  </action>
  <verify>
  Run: `grep -n "createClient" app/api/health/route.ts` -- should show both createClient and createServiceClient imports.
  Run: `grep -n "services" app/api/health/route.ts` -- should appear in the authenticated branch only (not in the unauthenticated response).
  Run: `grep -n "\"ok\"\|\"degraded\"" app/api/health/route.ts` -- should show the minimal response strings.
  Run: `pnpm lint` -- should pass.
  </verify>
  <done>
  Health endpoint returns full service details (database, ai-gateway, elevenlabs status) for authenticated users. Unauthenticated callers receive only `{status: "ok"}` or `{status: "degraded"}` with no internal service names. HTTP status codes 200/503 preserved for monitoring compatibility.
  </done>
</task>

</tasks>

<verification>
1. `grep -rn "z.object" app/\(chat\)/api/realtime/` -- Zod schemas in both route files
2. `grep -rn "typeof message" app/\(chat\)/api/realtime/` -- no manual type checks remaining
3. `grep -n "services" app/api/health/route.ts` -- only in authenticated response branch
4. `pnpm lint` passes with no new errors
</verification>

<success_criteria>
- Realtime routes reject messages over 5000 chars with 400 response
- Realtime routes reject invalid botType with 400 response
- Realtime stream route validates chatId as UUID when provided
- Malformed JSON bodies return 400 (not 500)
- Health endpoint hides service names from unauthenticated callers
- Health endpoint shows full details to authenticated users
- HTTP 200/503 status codes preserved on health endpoint
- Lint passes clean
</success_criteria>

<output>
After completion, create `.planning/phases/17-security-hardening/17-02-SUMMARY.md`
</output>
