---
phase: 16-model-resilience-tool-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/ai/tools/get-weather.ts
  - lib/ai/tools/request-suggestions.ts
  - lib/ai/tools/strategy-canvas.ts
autonomous: true

must_haves:
  truths:
    - "Weather tool errors (network failure, bad response, timeout) show a user-friendly message instead of crashing the chat"
    - "Weather API fetch has a 10s timeout that aborts on slow responses"
    - "requestSuggestions rejects unauthenticated users and users who don't own the document without leaking document existence"
    - "strategyCanvas rejects unauthenticated users before any DB operations"
  artifacts:
    - path: "lib/ai/tools/get-weather.ts"
      provides: "Weather tool with response validation, timeout, and error handling"
      contains: "AbortController"
    - path: "lib/ai/tools/request-suggestions.ts"
      provides: "Suggestions tool with auth check before document access"
      contains: "session.user.id"
    - path: "lib/ai/tools/strategy-canvas.ts"
      provides: "Canvas tool with specific error handling per failure mode"
      contains: "ChatSDKError"
  key_links:
    - from: "lib/ai/tools/get-weather.ts"
      to: "https://api.open-meteo.com"
      via: "fetch with AbortController timeout"
      pattern: "AbortController.*setTimeout.*10_000"
    - from: "lib/ai/tools/request-suggestions.ts"
      to: "lib/db/queries/document.ts"
      via: "getDocumentById with ownership check"
      pattern: "document\\.userId.*!==.*session\\.user\\.id"
---

<objective>
Harden all AI tool invocations so they fail safely with user-friendly errors instead of crashing or leaking information.

Purpose: The weather tool has no `response.ok` check and no timeout on its main fetch. The `requestSuggestions` tool doesn't verify document ownership (RLS hides data but returns "Document not found" for unauthorized access, leaking that the ID is valid). The `strategyCanvas` tool has a generic catch-all error that masks specific failures.

Output: Weather tool with full error handling (timeout, response validation, user-friendly messages), and both document tools with proper authorization checks that don't leak resource existence.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-model-resilience-tool-hardening/16-RESEARCH.md

@lib/ai/tools/get-weather.ts
@lib/ai/tools/request-suggestions.ts
@lib/ai/tools/strategy-canvas.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add timeout, response validation, and error handling to weather tool</name>
  <files>lib/ai/tools/get-weather.ts</files>
  <action>
Rewrite the `execute` function in the `getWeather` tool to add three layers of protection:

**1. AbortController with 10s timeout on the main weather fetch:**
```typescript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 10_000);
```
Pass `{ signal: controller.signal }` as the second argument to `fetch`. Call `clearTimeout(timeoutId)` immediately after `fetch` resolves (before `.json()`).

**2. Response.ok check:**
After `fetch`, check `if (!response.ok)` and return a user-friendly error object:
```typescript
if (!response.ok) {
  return { error: "The weather service is temporarily unavailable. Please try again in a moment." };
}
```

**3. Response structure validation:**
After `await response.json()`, validate the expected shape exists:
```typescript
if (!weatherData.current || typeof weatherData.current.temperature_2m !== "number") {
  return { error: "Received unexpected data from the weather service. Please try again." };
}
```

**4. Wrap everything in try/catch:**
Wrap the entire execute body (after coordinate resolution) in try/catch. Handle `AbortError` specifically:
```typescript
catch (error) {
  if (error instanceof DOMException && error.name === "AbortError") {
    return { error: "The weather request timed out. The service may be slow right now." };
  }
  return { error: "I couldn't fetch the weather right now. Please try again later." };
}
```

**5. Also add timeout to the geocoding fetch:**
Add the same AbortController pattern to the `geocodeCity` function with a 5s timeout. This prevents the geocoding step from hanging too.

Keep the existing city-name-to-coordinates logic and the `cityName` assignment on the result. All error returns must be objects with an `error` string field (matching the existing pattern from the geocode failure case).
  </action>
  <verify>
Run `grep -c "AbortController" lib/ai/tools/get-weather.ts` -- must return 2 (one for geocode, one for weather).
Run `grep -c "response.ok" lib/ai/tools/get-weather.ts` -- must return 2 (geocode already has it, weather now has it).
Run `grep -c "temperature_2m" lib/ai/tools/get-weather.ts` -- must return 2+ (in URL and in validation).
Run `grep "AbortError" lib/ai/tools/get-weather.ts` -- must find the timeout error handler.
Run `pnpm lint` -- must pass.
  </verify>
  <done>Weather tool has 10s timeout on weather fetch, 5s timeout on geocode, response.ok validation, response structure validation, and user-friendly error messages for all failure modes (timeout, bad response, unexpected data, network error).</done>
</task>

<task type="auto">
  <name>Task 2: Add authorization checks to requestSuggestions and strategyCanvas tools</name>
  <files>lib/ai/tools/request-suggestions.ts, lib/ai/tools/strategy-canvas.ts</files>
  <action>
**In `lib/ai/tools/request-suggestions.ts`:**

Add an explicit auth + ownership check at the top of the `execute` function, BEFORE the `getDocumentById` call:

1. First, check `session.user?.id` exists. If not, return `{ error: "You must be logged in to request suggestions." }`.
2. After `getDocumentById`, add an ownership check. The key is to return the SAME error message whether the document doesn't exist, has no content, or belongs to another user -- this prevents leaking document existence:
```typescript
if (!document || !document.content || document.userId !== session.user.id) {
  return { error: "Document not found or access denied." };
}
```
This replaces the current check which only tests `!document || !document.content` and returns "Document not found" (leaking that the ID exists but belongs to someone else when RLS filters it).

3. Move the `session.user?.id` check for saving suggestions (currently at line 80) to the top -- it's now guaranteed by the first check.

**In `lib/ai/tools/strategy-canvas.ts`:**

The tool already checks `session?.user?.id` at the top (line 89) which is good. Add more specific error handling in the catch block:

1. Import `ChatSDKError` from `@/lib/errors`.
2. Replace the generic catch block with specific error handling:
```typescript
catch (error) {
  if (error instanceof ChatSDKError) {
    return { success: false, message: "Database error while saving canvas data. Please try again." };
  }
  console.error("[Strategy Canvas] Unexpected error:", error);
  return { success: false, message: "An unexpected error occurred while saving canvas data. Please try again." };
}
```
This differentiates known DB errors from unexpected errors in the logs, while still returning user-friendly messages to both.
  </action>
  <verify>
Run `grep "session.user" lib/ai/tools/request-suggestions.ts` -- must show auth check before getDocumentById.
Run `grep "document.userId" lib/ai/tools/request-suggestions.ts` -- must show ownership check.
Run `grep "Document not found or access denied" lib/ai/tools/request-suggestions.ts` -- must return 1 (uniform error).
Run `grep "ChatSDKError" lib/ai/tools/strategy-canvas.ts` -- must show import and instanceof check.
Run `pnpm lint` -- must pass.
  </verify>
  <done>requestSuggestions has auth check + ownership check with uniform error message (no existence leak). strategyCanvas has specific error handling per failure mode (ChatSDKError vs unexpected). Both tools reject unauthorized users before any DB operations.</done>
</task>

</tasks>

<verification>
Requirements covered:
- TOOL-01: Weather API validates `response.ok`, validates response structure, and wraps in try/catch with user-friendly error
- TOOL-02: Weather API fetch has AbortController with 10s timeout
- TOOL-03: `requestSuggestions` has explicit auth + ownership check without leaking document existence
- TOOL-04: `strategyCanvas` has fast-fail auth (already existed) + specific error handling per failure mode

All tools return user-friendly error messages. No technical error details exposed to users.
</verification>

<success_criteria>
1. Weather fetch has AbortController with 10s timeout
2. Weather fetch checks `response.ok` before parsing JSON
3. Weather fetch validates `current.temperature_2m` exists and is a number
4. Weather catch handles AbortError specifically with timeout message
5. requestSuggestions checks auth before getDocumentById
6. requestSuggestions returns same error for "not found" and "not yours"
7. strategyCanvas catch differentiates ChatSDKError from unexpected errors
8. `pnpm lint` passes
</success_criteria>

<output>
After completion, create `.planning/phases/16-model-resilience-tool-hardening/16-02-SUMMARY.md`
</output>
