---
phase: 13-ai-content-voice
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - hooks/use-voice-call.ts
  - app/(chat)/api/realtime/stream/route.ts
  - components/premium-realtime-call.tsx
autonomous: true

must_haves:
  truths:
    - "Voice call questions and AI answers appear in the chat history after the call ends"
    - "Basic voice call (use-voice-call.ts) TTS requests succeed by sending correct botType parameter"
    - "Premium realtime voice call creates per-session chats with descriptive titles instead of one mega 'Voice Call' chat"
  artifacts:
    - path: "hooks/use-voice-call.ts"
      provides: "Fixed voice call hook sending botType (not voiceId) to /api/voice"
      contains: "botType"
    - path: "app/(chat)/api/realtime/stream/route.ts"
      provides: "Per-session voice chats with AI-generated titles"
      contains: "crypto.randomUUID"
    - path: "components/premium-realtime-call.tsx"
      provides: "SWR cache invalidation after voice call ends"
  key_links:
    - from: "hooks/use-voice-call.ts"
      to: "app/(chat)/api/voice/route.ts"
      via: "fetch /api/voice with { text, botType }"
      pattern: "botType.*selectedBot"
    - from: "app/(chat)/api/realtime/stream/route.ts"
      to: "lib/db/queries"
      via: "saveMessages to per-session chat"
      pattern: "saveMessages"
    - from: "components/premium-realtime-call.tsx"
      to: "SWR mutate"
      via: "mutate('/api/history') after call ends"
      pattern: "mutate.*history"
---

<objective>
Fix voice call chat persistence so Q&A appears in browseable chat history, fix the basic voice call hook's broken TTS request, and improve premium realtime path to create per-session chats with descriptive titles.

Purpose: VOICE-01 requires voice call conversations to be visible in chat history. The basic voice call hook has a bug (sends `voiceId` instead of `botType` to /api/voice, failing Zod validation). The premium realtime path reuses a single "Voice Call" chat for all calls, making it impossible to find specific conversations.
Output: Working voice call persistence across both paths with proper chat titles.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-ai-content-voice/13-RESEARCH.md
@hooks/use-voice-call.ts
@app/(chat)/api/realtime/stream/route.ts
@components/premium-realtime-call.tsx
@app/(chat)/api/voice/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix basic voice call TTS request and verify persistence</name>
  <files>hooks/use-voice-call.ts</files>
  <action>
**Bug fix:** In `speakVoiceResponse` (around line 151), the fetch call sends `{ text, voiceId }` to `/api/voice`. But the voice route validates with Zod: `{ text: string, botType: "alexandria" | "kim" | "collaborative" }`. The `voiceId` field is ignored and `botType` is missing, so every TTS request during a basic voice call FAILS Zod validation silently.

Fix: Change line 151 from:
```
body: JSON.stringify({ text, voiceId }),
```
to:
```
body: JSON.stringify({ text, botType: selectedBot }),
```

Also remove the unused `getVoiceForBot` import from `@/lib/ai/voice-config` (line 4) and remove the `const voiceId = getVoiceForBot(selectedBot)` call (line 147) since the voice route handles voice selection internally based on botType.

**Persistence verification:** The basic voice call path already persists messages correctly because `sendMessage` goes through the normal `/api/chat` route which saves to the current chat. No changes needed for persistence itself, just the TTS bug fix. The messages ARE in the chat -- they just couldn't be read aloud because the TTS request was malformed.
  </action>
  <verify>
1. `pnpm lint` passes.
2. Grep `use-voice-call.ts` for `voiceId` -- should return zero matches (removed).
3. Grep `use-voice-call.ts` for `botType: selectedBot` -- should return one match in the fetch body.
  </verify>
  <done>
Basic voice call hook sends correct `botType` parameter to `/api/voice`. TTS requests during voice calls will succeed Zod validation. The unused `getVoiceForBot` import is removed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Improve premium realtime voice chat persistence with per-session chats and SWR refresh</name>
  <files>
    app/(chat)/api/realtime/stream/route.ts
    components/premium-realtime-call.tsx
  </files>
  <action>
**In `app/(chat)/api/realtime/stream/route.ts`:**

Change the chat persistence logic (lines 350-411) to create a NEW chat for each voice session instead of reusing a single "Voice Call" chat:

1. Remove the query that looks for `existingChat` with `title: "Voice Call"` (lines 357-362).
2. Always create a new chat with `id: crypto.randomUUID()`.
3. Generate a descriptive title from the user's first message. Use a simple approach: take the first 50 characters of the user's `message` and use it as the title. If the message is longer than 50 chars, truncate at the last word boundary and add "...". Example: "How do I improve my email open rates..." instead of generic "Voice Call".
4. Set the chat title to this descriptive title.
5. Keep the `botType` assignment on the chat.
6. Keep the `savedChatId` assignment and return it in the response.

The modified persistence section should look approximately like:
```typescript
const chatId = crypto.randomUUID();
savedChatId = chatId;

// Generate descriptive title from user message
let title = message.trim();
if (title.length > 50) {
  title = title.slice(0, 50).replace(/\s+\S*$/, '') + '...';
}
if (!title) {
  title = 'Voice Call';
}

const { error: insertError } = await supabase.from("Chat").insert({
  id: chatId,
  userId: user.id,
  title,
  botType: botType as BotType,
});
```

**In `components/premium-realtime-call.tsx`:**

Find the call-end handler (where the component transitions from active call to ended state or where the chatId redirect happens). After a successful voice call that returned a chatId:

1. Import `useSWRConfig` from `swr` (or use the existing `mutate` if already imported).
2. After the call ends and before/during redirect to the chat, call `mutate('/api/history')` to invalidate the sidebar chat list so the new voice chat appears immediately without a page reload.

Look for the pattern where `chatId` is received from the API response and the component handles navigation. Add the SWR invalidation there. If the component uses `router.push` to navigate to the new chat, add `mutate('/api/history')` right before the navigation.

If `useSWRConfig` is not already imported, add it. The import is: `import { useSWRConfig } from "swr"` and destructure `{ mutate }` from the hook call inside the component.
  </action>
  <verify>
1. `pnpm lint` passes.
2. Grep `realtime/stream/route.ts` for `"Voice Call"` -- should return zero matches (no more hardcoded "Voice Call" title lookup).
3. Grep `realtime/stream/route.ts` for `crypto.randomUUID()` -- should appear (new chat ID generation).
4. Grep `premium-realtime-call.tsx` for `mutate` -- should appear (SWR cache invalidation).
  </verify>
  <done>
Premium realtime voice calls create per-session chats with descriptive titles derived from the user's question. The sidebar chat list refreshes via SWR invalidation after the call ends. Users can find and revisit specific voice conversations in their chat history.
  </done>
</task>

</tasks>

<verification>
1. `pnpm lint` passes with no errors
2. `hooks/use-voice-call.ts` sends `botType` (not `voiceId`) to /api/voice
3. `app/(chat)/api/realtime/stream/route.ts` creates new chats per session with descriptive titles
4. `components/premium-realtime-call.tsx` invalidates SWR cache after call ends
5. No "Voice Call" hardcoded title lookup remains in the realtime route
</verification>

<success_criteria>
- Basic voice call TTS works (sends correct botType parameter)
- Premium realtime voice calls create per-session chats with descriptive titles
- New voice chats appear in the sidebar immediately (SWR cache invalidation)
- Voice call Q&A is visible in chat history across both paths
- pnpm lint passes
</success_criteria>

<output>
After completion, create `.planning/phases/13-ai-content-voice/13-02-SUMMARY.md`
</output>
