---
phase: 25-security-performance-cost-controls
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/ai/models.ts
  - lib/ai/providers.ts
  - app/api/demo/chat/route.ts
  - lib/cost/tracker.ts
  - app/api/cron/cost-check/route.ts
  - supabase/migrations/20260219000100_add_aicostlog_userid_index.sql
autonomous: true

must_haves:
  truths:
    - "Model documentation matches actual model used (Gemini 2.5 Flash, not Gemini 3 Flash Pro)"
    - "Provider configuration includes version tracking comments for model pinning awareness"
    - "Demo chat logs token usage via the existing recordAICost infrastructure"
    - "Per-user daily spending can be queried and anomalous users are flagged in the cost-check cron"
  artifacts:
    - path: "lib/ai/models.ts"
      provides: "Correct model name and description"
      contains: "Gemini 2.5 Flash"
    - path: "lib/ai/providers.ts"
      provides: "Version tracking documentation comments"
      contains: "Last verified"
    - path: "app/api/demo/chat/route.ts"
      provides: "Cost tracking in demo chat onFinish"
      contains: "recordAICost"
    - path: "lib/cost/tracker.ts"
      provides: "Per-user daily cost query function"
      exports: ["getUserDailyCost"]
    - path: "app/api/cron/cost-check/route.ts"
      provides: "Per-user anomaly detection in daily cron"
      contains: "getTopUserCosts"
    - path: "supabase/migrations/20260219000100_add_aicostlog_userid_index.sql"
      provides: "userId index on AICostLog for per-user queries"
      contains: "CREATE INDEX"
  key_links:
    - from: "app/api/demo/chat/route.ts"
      to: "lib/cost/tracker.ts"
      via: "recordAICost call in onFinish"
      pattern: "recordAICost"
    - from: "app/api/cron/cost-check/route.ts"
      to: "lib/cost/tracker.ts"
      via: "getTopUserCosts for anomaly detection"
      pattern: "getTopUserCosts"
---

<objective>
Align model documentation with actual models, add cost tracking to demo chat, and implement per-user spending alerts.

Purpose: Ensure model references are accurate for operational clarity, capture demo chat costs for complete cost visibility, and detect per-user spending anomalies.
Output: Correct model docs, demo cost logging, per-user cost aggregation with anomaly alerting.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-security-performance-cost-controls/25-RESEARCH.md
@lib/ai/models.ts
@lib/ai/providers.ts
@lib/cost/tracker.ts
@app/api/demo/chat/route.ts
@app/api/cron/cost-check/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix model documentation and add version tracking (COST-01, COST-02)</name>
  <files>
    lib/ai/models.ts
    lib/ai/providers.ts
  </files>
  <action>
    **COST-02: Fix model documentation in lib/ai/models.ts**

    The current `chatModels` array has:
    ```typescript
    {
      id: "chat-model",
      name: "Gemini 3 Flash Pro",
      description: "High-performance thinking model via OpenRouter",
    }
    ```

    "Gemini 3 Flash Pro" does not exist. The actual model is `google/gemini-2.5-flash` (Gemini 2.5 Flash, stable GA). Change to:
    ```typescript
    {
      id: "chat-model",
      name: "Gemini 2.5 Flash",
      description: "High-performance AI model via OpenRouter (stable)",
    }
    ```

    **COST-01: Add version tracking comments to lib/ai/providers.ts**

    Add a documentation block before the `customProvider` definition (before line 84) to make model version pinning explicit:

    ```typescript
    /**
     * Model Version Configuration
     *
     * Primary: google/gemini-2.5-flash (OpenRouter stable alias)
     *   - Auto-updates when Google promotes new stable versions
     *   - OpenRouter fallback chain: gemini-2.5-flash -> gemini-2.5-flash-lite
     *
     * Secondary (direct Google fallback): gemini-2.0-flash
     *   - Used when OpenRouter is completely down
     *   - Set GOOGLE_AI_API_KEY env var to enable
     *
     * For date-pinned versions (testing only):
     *   google/gemini-2.5-flash-preview-09-2025
     *
     * Monitor actual model via OpenRouter response header: x-model-id
     *
     * Last verified: 2026-02-19
     */
    ```

    Keep using `google/gemini-2.5-flash` (the stable alias) rather than date-pinning. Research confirms: stable aliases are appropriate for production, date-pinned previews are for testing.

    Also update the inline comments on each model slot to be accurate. The current comments already say "Gemini 2.5 Flash (stable)" which is correct -- no change needed there.
  </action>
  <verify>
    1. `grep "Gemini 3" lib/ai/models.ts` returns no matches (old incorrect name removed).
    2. `grep "Gemini 2.5 Flash" lib/ai/models.ts` returns a match (correct name).
    3. `grep "Last verified" lib/ai/providers.ts` returns a match (version tracking comment).
    4. `pnpm build` passes.
  </verify>
  <done>Model documentation correctly references Gemini 2.5 Flash. Provider file includes version tracking documentation with pinning guidance. No code behavior changes.</done>
</task>

<task type="auto">
  <name>Task 2: Add demo cost tracking and per-user spending alerts (COST-03, COST-04)</name>
  <files>
    app/api/demo/chat/route.ts
    lib/cost/tracker.ts
    app/api/cron/cost-check/route.ts
    supabase/migrations/20260219000100_add_aicostlog_userid_index.sql
  </files>
  <action>
    **COST-03: Demo chat cost tracking in app/api/demo/chat/route.ts**

    The demo route currently uses `streamText` inside `createUIMessageStream.execute()` but does NOT capture usage data. The `onFinish` callback of `createUIMessageStream` receives `messages` but not token usage.

    To capture usage, we need to access the `result` object from `streamText`. The `result` is already defined inside `execute` but not exposed. Approach: use a variable in the outer closure to capture usage.

    Add `import { after } from "next/server";` and `import { recordAICost } from "@/lib/cost/tracker";` to the imports.

    Refactor the streaming section to capture usage:

    ```typescript
    // Track usage for cost logging
    let streamResult: ReturnType<typeof streamText> | null = null;

    const stream = createUIMessageStream({
      execute: ({ writer: dataStream }) => {
        const result = streamText({
          model: myProvider.languageModel("chat-model"),
          system: systemPromptText,
          messages: convertToModelMessages(recentMessages),
          maxOutputTokens: 1024,
          experimental_telemetry: {
            isEnabled: isProductionEnvironment,
            functionId: "demo-stream-text",
          },
        });

        streamResult = result;
        result.consumeStream();
        dataStream.merge(
          result.toUIMessageStream({
            sendReasoning: false,
          }),
        );
      },
      // ... keep existing callbacks
      onFinish: async ({ messages: finishedMessages }) => {
        recordCircuitSuccess("ai-gateway");

        // COST-03: Log token usage for demo chat
        if (streamResult) {
          after(async () => {
            try {
              const usage = await streamResult!.usage;
              if (usage) {
                await recordAICost({
                  userId: "demo-anonymous",
                  chatId: `demo-${Date.now()}`,
                  modelId: "google/gemini-2.5-flash",
                  inputTokens: usage.promptTokens ?? 0,
                  outputTokens: usage.completionTokens ?? 0,
                  costUSD: 0, // Demo costs tracked as 0 USD (tokens only for monitoring)
                });
              }
            } catch (costErr) {
              logger.warn({ err: costErr }, "Failed to record demo chat cost");
            }
          });
        }

        // ... keep existing safety scan logic unchanged
      },
    });
    ```

    Note: `streamText` returns a `StreamTextResult` where `usage` is a Promise that resolves after streaming completes. Inside `onFinish`, the stream is done, so `await streamResult.usage` should resolve immediately.

    Also, to capture actual cost, use tokenlens if available. But for simplicity, log tokens with $0 cost (demo is free tier). The important thing is having the data for monitoring.

    **COST-04: Per-user spending alerts in lib/cost/tracker.ts**

    Add two new functions to `lib/cost/tracker.ts`:

    ```typescript
    interface UserDailyCost {
      userId: string;
      totalCostUSD: number;
      requestCount: number;
    }

    /**
     * Get per-user daily cost totals for a given date.
     * Returns top N users by cost, descending.
     */
    export async function getTopUserCosts(
      date?: Date,
      topN = 10,
    ): Promise<UserDailyCost[]> {
      const targetDate = date ?? new Date();
      const dateStr = targetDate.toISOString().split("T")[0];

      const supabase = createServiceClient();
      const { data, error } = (await (supabase.from as any)("AICostLog")
        .select("userId, costUSD")
        .gte("createdAt", `${dateStr}T00:00:00.000Z`)
        .lt("createdAt", `${dateStr}T23:59:59.999Z`)) as {
        data: Array<{ userId: string; costUSD: number }> | null;
        error: any;
      };

      if (error) {
        logger.error({ err: error }, "Failed to query per-user AI costs");
        throw error;
      }

      const rows = data ?? [];
      const userMap = new Map<string, { totalCostUSD: number; requestCount: number }>();
      for (const row of rows) {
        const existing = userMap.get(row.userId) ?? { totalCostUSD: 0, requestCount: 0 };
        existing.totalCostUSD += Number(row.costUSD ?? 0);
        existing.requestCount += 1;
        userMap.set(row.userId, existing);
      }

      return Array.from(userMap.entries())
        .map(([userId, stats]) => ({ userId, ...stats }))
        .sort((a, b) => b.totalCostUSD - a.totalCostUSD)
        .slice(0, topN);
    }

    /**
     * Get daily cost for a specific user.
     */
    export async function getUserDailyCost(
      userId: string,
      date?: Date,
    ): Promise<{ totalCostUSD: number; requestCount: number }> {
      const targetDate = date ?? new Date();
      const dateStr = targetDate.toISOString().split("T")[0];

      const supabase = createServiceClient();
      const { data, error } = (await (supabase.from as any)("AICostLog")
        .select("costUSD")
        .eq("userId", userId)
        .gte("createdAt", `${dateStr}T00:00:00.000Z`)
        .lt("createdAt", `${dateStr}T23:59:59.999Z`)) as {
        data: Array<{ costUSD: number }> | null;
        error: any;
      };

      if (error) throw error;
      const rows = data ?? [];

      return {
        totalCostUSD: rows.reduce((sum, r) => sum + Number(r.costUSD ?? 0), 0),
        requestCount: rows.length,
      };
    }
    ```

    **COST-04: Integrate per-user alerts into app/api/cron/cost-check/route.ts**

    Import `getTopUserCosts` from `@/lib/cost/tracker`. After the existing global threshold check, add per-user anomaly detection:

    ```typescript
    // Per-user anomaly detection: flag users with disproportionate usage
    const topUsers = await getTopUserCosts(undefined, 5);
    const avgCostPerUser = daily.uniqueUsers > 0
      ? daily.totalCostUSD / daily.uniqueUsers
      : 0;

    const anomalousUsers = topUsers.filter(
      (u) => u.totalCostUSD > avgCostPerUser * 10 && u.totalCostUSD > 0.50
    );

    if (anomalousUsers.length > 0) {
      const userDetails = anomalousUsers
        .map((u) => `  - ${u.userId}: $${u.totalCostUSD.toFixed(4)} (${u.requestCount} requests)`)
        .join("\n");

      await sendAdminNotification({
        subject: `AI Per-User Spending Anomaly: ${anomalousUsers.length} user(s)`,
        message: `The following users spent >10x the average daily cost ($${avgCostPerUser.toFixed(4)}/user):\n\n${userDetails}\n\nTotal daily spend: $${daily.totalCostUSD.toFixed(4)}`,
        type: "alert",
      });

      logger.warn(
        { anomalousUsers: anomalousUsers.map((u) => u.userId), avgCostPerUser },
        "Per-user cost anomaly detected",
      );
    }
    ```

    Include the per-user data in the cron response JSON:
    ```typescript
    return NextResponse.json({
      success: true,
      ...daily,
      thresholdUSD: DAILY_COST_THRESHOLD_USD,
      thresholdExceeded: daily.totalCostUSD > DAILY_COST_THRESHOLD_USD,
      topUsers: topUsers.slice(0, 5),
      anomalousUsers: anomalousUsers.length,
      timestamp: new Date().toISOString(),
    });
    ```

    **Database: Add userId index to AICostLog**

    Create migration file `supabase/migrations/20260219000100_add_aicostlog_userid_index.sql`:
    ```sql
    -- Add userId index to AICostLog for per-user cost queries (COST-04)
    -- This index supports efficient per-user aggregation in getTopUserCosts and getUserDailyCost
    CREATE INDEX IF NOT EXISTS idx_aicostlog_userid ON "AICostLog" ("userId");

    -- Composite index for per-user daily queries (userId + date range)
    CREATE INDEX IF NOT EXISTS idx_aicostlog_userid_created ON "AICostLog" ("userId", "createdAt");
    ```

    Add a note to STATE.md that this migration needs to be applied via Supabase Dashboard SQL Editor.
  </action>
  <verify>
    1. `pnpm build` passes with all changes.
    2. `grep "recordAICost" app/api/demo/chat/route.ts` shows cost tracking in the demo route.
    3. `grep "getTopUserCosts\|getUserDailyCost" lib/cost/tracker.ts` shows both new functions.
    4. `grep "anomalousUsers\|topUsers" app/api/cron/cost-check/route.ts` shows per-user alerting.
    5. Migration file exists at `supabase/migrations/20260219000100_add_aicostlog_userid_index.sql`.
  </verify>
  <done>Demo chat logs token usage for cost monitoring. Per-user daily costs are queryable. Cost-check cron flags users spending >10x the average with admin notifications. AICostLog userId index migration is ready for application.</done>
</task>

</tasks>

<verification>
1. `pnpm build` passes with all changes
2. Model documentation references correct "Gemini 2.5 Flash" everywhere
3. Demo chat route calls recordAICost in onFinish
4. Per-user cost functions exist in tracker.ts
5. Cost-check cron includes per-user anomaly detection
6. Migration file for userId index exists
</verification>

<success_criteria>
- models.ts says "Gemini 2.5 Flash" (not "Gemini 3 Flash Pro")
- providers.ts has version tracking documentation
- Demo chat logs token usage via recordAICost
- Per-user daily/monthly costs are queryable via getTopUserCosts / getUserDailyCost
- Cost-check cron flags anomalous per-user spending
- AICostLog userId index migration ready for deployment
</success_criteria>

<output>
After completion, create `.planning/phases/25-security-performance-cost-controls/25-03-SUMMARY.md`
</output>
