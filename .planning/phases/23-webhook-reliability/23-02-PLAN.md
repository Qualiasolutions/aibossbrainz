---
phase: 23-webhook-reliability
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - app/api/stripe/webhook/route.ts
  - lib/stripe/webhook-dedup.ts
  - supabase/migrations/20260218000200_webhook_reliability.sql
autonomous: true
user_setup:
  - service: supabase
    why: "Updated migration must be re-applied via Supabase Dashboard SQL Editor (replaces the Plan 01 migration if not yet applied, or run as additive if already applied)"
    dashboard_config:
      - task: "Apply the updated migration with WebhookDeadLetter table and process_webhook_event RPC function"
        location: "Supabase Dashboard -> SQL Editor -> paste migration content"

must_haves:
  truths:
    - "Concurrent webhook events for the same user are serialized via advisory lock"
    - "Failed webhook events are persisted to WebhookDeadLetter table for inspection"
    - "Webhook endpoint rejects excessive requests via IP-based rate limiting"
    - "Dead-letter persistence does not itself cause webhook failure (isolated error handling)"
  artifacts:
    - path: "app/api/stripe/webhook/route.ts"
      provides: "Rate limiting + dead-letter persistence in catch block"
      contains: "WebhookDeadLetter"
    - path: "lib/stripe/webhook-dedup.ts"
      provides: "Advisory lock via process_webhook_event RPC"
      exports: ["shouldProcessEvent", "persistFailedEvent"]
    - path: "supabase/migrations/20260218000200_webhook_reliability.sql"
      provides: "WebhookDeadLetter table + process_webhook_event RPC function"
      contains: "pg_advisory_xact_lock"
  key_links:
    - from: "app/api/stripe/webhook/route.ts"
      to: "lib/stripe/webhook-dedup.ts"
      via: "import shouldProcessEvent, persistFailedEvent"
      pattern: "shouldProcessEvent|persistFailedEvent"
    - from: "lib/stripe/webhook-dedup.ts"
      to: "process_webhook_event RPC"
      via: "supabase.rpc('process_webhook_event')"
      pattern: "process_webhook_event"
    - from: "app/api/stripe/webhook/route.ts"
      to: "lib/security/rate-limiter.ts"
      via: "checkAuthRateLimit or similar IP-based check"
      pattern: "checkAuthRateLimit|checkWebhookRateLimit"
---

<objective>
Add advisory locking for race condition prevention, dead-letter queue for failure persistence, and IP-based rate limiting to the Stripe webhook endpoint.

Purpose: Fix low-severity audit findings L-8 through L-10 -- concurrent events for the same user can race, failed events are silently lost, and the endpoint has no DoS protection beyond signature verification.
Output: Webhook route with advisory locks serializing per-user events, WebhookDeadLetter table capturing failures, and IP-based rate limiting.
</objective>

<execution_context>
@/home/qualia/.claude/get-shit-done/workflows/execute-plan.md
@/home/qualia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-webhook-reliability/23-RESEARCH.md
@.planning/phases/23-webhook-reliability/23-01-SUMMARY.md
@app/api/stripe/webhook/route.ts
@lib/stripe/webhook-dedup.ts
@lib/security/rate-limiter.ts
@supabase/migrations/20260218000200_webhook_reliability.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add advisory lock RPC, dead-letter table, and dedup module upgrades</name>
  <files>
    supabase/migrations/20260218000200_webhook_reliability.sql
    lib/stripe/webhook-dedup.ts
  </files>
  <action>
    1. Update migration `supabase/migrations/20260218000200_webhook_reliability.sql` to ADD (do not remove existing StripeWebhookEvent table creation):

       a. Create `WebhookDeadLetter` table:
          - `id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text`
          - `"eventId" TEXT NOT NULL`
          - `"eventType" TEXT NOT NULL`
          - `"payload" JSONB NOT NULL`
          - `"error" TEXT NOT NULL`
          - `"failedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW()`
          - `"resolvedAt" TIMESTAMPTZ` (nullable -- set when manually resolved/replayed)
          - Enable RLS + service-role-only policy (same pattern as StripeWebhookEvent)
          - Index on `"failedAt"` for cleanup queries
          - Index on `"resolvedAt"` for filtering unresolved entries

       b. Create `process_webhook_event` RPC function:
          ```sql
          CREATE OR REPLACE FUNCTION process_webhook_event(
            p_event_id TEXT,
            p_event_type TEXT,
            p_user_id TEXT DEFAULT NULL
          ) RETURNS BOOLEAN
          LANGUAGE plpgsql
          SECURITY DEFINER
          SET search_path = public
          AS $$
          DECLARE
            v_lock_key BIGINT;
          BEGIN
            -- Acquire advisory lock scoped to user for serialization
            IF p_user_id IS NOT NULL THEN
              v_lock_key := hashtext('webhook:' || p_user_id);
              PERFORM pg_advisory_xact_lock(v_lock_key);
            END IF;

            -- Check if event already processed (idempotency)
            IF EXISTS (SELECT 1 FROM "StripeWebhookEvent" WHERE "eventId" = p_event_id) THEN
              RETURN FALSE;
            END IF;

            -- Mark event as processed
            INSERT INTO "StripeWebhookEvent" ("eventId", "eventType", "userId", "processedAt")
            VALUES (p_event_id, p_event_type, p_user_id, NOW());

            RETURN TRUE;
          END;
          $$;
          ```

    2. Update `lib/stripe/webhook-dedup.ts`:

       a. Replace `markEventProcessed` with `shouldProcessEvent` that uses the RPC function:
          ```typescript
          export async function shouldProcessEvent(
            eventId: string,
            eventType: string,
            userId: string | null,
          ): Promise<boolean> {
            const supabase = createServiceClient();
            const { data, error } = await supabase.rpc("process_webhook_event", {
              p_event_id: eventId,
              p_event_type: eventType,
              p_user_id: userId,
            });

            if (error) {
              logger.error({ err: error, eventId }, "Failed to check webhook dedup");
              throw error;
            }

            return data === true;
          }
          ```

       b. Add `persistFailedEvent` function:
          ```typescript
          export async function persistFailedEvent(
            eventId: string,
            eventType: string,
            payload: unknown,
            errorMessage: string,
          ): Promise<void> {
            try {
              const supabase = createServiceClient();
              await supabase.from("WebhookDeadLetter").insert({
                eventId,
                eventType,
                payload: payload as Json,
                error: errorMessage,
                failedAt: new Date().toISOString(),
              });
            } catch (dlqError) {
              // Dead-letter persistence must never cause the webhook to fail differently
              logger.error({ err: dlqError, eventId }, "Failed to persist dead-letter event");
            }
          }
          ```

       c. Import `Json` type from `@/lib/supabase/types` for the payload typing.

       d. Keep the old `markEventProcessed` function but mark it deprecated with a comment, OR remove it entirely if Plan 01's webhook route now uses `shouldProcessEvent` instead. The route.ts will be updated in Task 2 to use the new function name.
  </action>
  <verify>
    - `pnpm build` compiles without errors
    - `grep -c "pg_advisory_xact_lock" supabase/migrations/20260218000200_webhook_reliability.sql` returns 1
    - `grep -c "WebhookDeadLetter" supabase/migrations/20260218000200_webhook_reliability.sql` returns 3+ (table, RLS, policy)
    - `grep -c "shouldProcessEvent" lib/stripe/webhook-dedup.ts` returns 1+ (exported)
    - `grep -c "persistFailedEvent" lib/stripe/webhook-dedup.ts` returns 1+ (exported)
  </verify>
  <done>
    Migration includes WebhookDeadLetter table and process_webhook_event RPC with advisory locking. webhook-dedup.ts exports shouldProcessEvent (using RPC) and persistFailedEvent (for dead-letter queue).
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate advisory lock, dead-letter queue, and rate limiting into webhook route</name>
  <files>
    app/api/stripe/webhook/route.ts
  </files>
  <action>
    1. Update imports: Replace `markEventProcessed` with `shouldProcessEvent` and add `persistFailedEvent` from `@/lib/stripe/webhook-dedup`. Import `checkAuthRateLimit` from `@/lib/security/rate-limiter`.

    2. Add IP-based rate limiting BEFORE signature verification (to reject floods early):
       - Extract IP from `headersList.get("x-forwarded-for")?.split(",")[0]?.trim() || "unknown"`
       - Call `checkAuthRateLimit(ip, "login", 100)` -- reusing "login" action type with a high limit (100 per 15-min window). The checkAuthRateLimit function already handles Redis primary + in-memory fallback. 100 is high enough for legitimate Stripe bursts (billing cycles) but prevents DoS.
       - IMPORTANT: Do NOT create a new rate limit function. Reuse `checkAuthRateLimit` which already has Redis + in-memory fallback. The "login" action type with maxAttempts=100 is a pragmatic choice. If the team later wants a dedicated "webhook" action, that's a simple refactor. Alternatively, if the type constraint prevents using "login", create a new exported function `checkWebhookRateLimit` in rate-limiter.ts with the same pattern but accepting a "webhook" action string. Keep the implementation simple -- match checkAuthRateLimit's pattern exactly.
       - If rate limited, return `NextResponse.json({ error: "Too many requests" }, { status: 429 })` with `Retry-After` header set to the reset time.

    3. Replace the `markEventProcessed` call (from Plan 01) with `shouldProcessEvent`:
       - Change: `const isNew = await markEventProcessed(event.id, event.type, extractUserId(event));`
       - To: `const isNew = await shouldProcessEvent(event.id, event.type, extractUserId(event));`
       - The behavior is the same (returns true for new events, false for duplicates) but now uses advisory locking via RPC.

    4. Update the catch block to persist failed events to the dead-letter queue:
       - In the existing `catch (error)` block at the bottom of the try/catch:
         ```typescript
         } catch (error) {
           reqLog.error({ err: error }, "Error processing webhook event");

           // Persist failed event for inspection/replay
           await persistFailedEvent(
             event.id,
             event.type,
             event, // Full event payload for replay
             error instanceof Error ? error.message : String(error),
           );

           return NextResponse.json(
             { error: "Webhook handler failed" },
             { status: 500 },
           );
         }
         ```
       - Note: `persistFailedEvent` has its own try/catch internally, so if dead-letter persistence fails, it logs the error but does NOT prevent the 500 response.
       - Return 500 (not 200) on failure so Stripe retries. The dead-letter table is for inspection, not a replacement for retries.

    5. Do NOT modify any of the event handler logic (switch cases) or `after()` blocks. The only changes are:
       - Rate limiting at the top
       - Dedup function name change (markEventProcessed -> shouldProcessEvent)
       - Dead-letter persistence in the catch block
  </action>
  <verify>
    - `pnpm build` succeeds
    - `pnpm lint` passes
    - `grep -c "shouldProcessEvent" app/api/stripe/webhook/route.ts` returns 1+
    - `grep -c "persistFailedEvent" app/api/stripe/webhook/route.ts` returns 1+
    - `grep -c "checkAuthRateLimit\|checkWebhookRateLimit" app/api/stripe/webhook/route.ts` returns 1+
    - `grep -c "429" app/api/stripe/webhook/route.ts` returns 1 (rate limit response)
    - `grep -c "markEventProcessed" app/api/stripe/webhook/route.ts` returns 0 (old function replaced)
  </verify>
  <done>
    Webhook route uses advisory-lock-backed shouldProcessEvent for dedup (serializes concurrent events for same user). Failed events are persisted to WebhookDeadLetter. IP-based rate limiting rejects excessive requests with 429 before signature verification.
  </done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds with no type errors
- `pnpm lint` passes
- Migration SQL contains: StripeWebhookEvent table, WebhookDeadLetter table, process_webhook_event RPC with pg_advisory_xact_lock
- Webhook route has: maxDuration = 60, rate limiting, shouldProcessEvent (advisory lock dedup), persistFailedEvent (dead-letter)
- No trace of `markEventProcessed` or `isAlreadyProcessed` in the webhook route
- Dead-letter persistence is wrapped in try/catch (does not block webhook response)
- Rate limiting returns 429 with Retry-After header
</verification>

<success_criteria>
1. process_webhook_event RPC uses pg_advisory_xact_lock keyed on userId hash for serialization
2. WebhookDeadLetter table exists with eventId, eventType, payload, error, failedAt, resolvedAt columns
3. Failed webhook events are persisted before returning 500
4. Webhook endpoint rate limits at 100 requests per 15-min window per IP
5. Rate limiting uses existing checkAuthRateLimit pattern (Redis primary + in-memory fallback)
</success_criteria>

<output>
After completion, create `.planning/phases/23-webhook-reliability/23-02-SUMMARY.md`
</output>
